# HP33120A

Arbitrary Waveform Generator - 15MHz, 12-bit DAC (0-2047), 8-16000 points, 40 MSa/s.

## Import

```python
from gtape_prologix_drivers import HP33120A
```

## Constructor

```python
HP33120A(adapter)
```

| Parameter | Type | Description |
|-----------|------|-------------|
| `adapter` | PrologixAdapter | Connected adapter instance |

## Class Constants

| Constant | Value | Description |
|----------|-------|-------------|
| `DAC_MIN` | 0 | Minimum DAC value |
| `DAC_MAX` | 2047 | Maximum DAC value (12-bit) |
| `MIN_POINTS` | 8 | Minimum waveform points |
| `MAX_POINTS` | 16000 | Maximum waveform points |

---

## Quick Setup

### setup_arbitrary_waveform

```python
awg.setup_arbitrary_waveform(
    waveform_data,
    name: str = "PULSE",
    frequency: float = 5000,
    voltage: float = 0.5,
    load: int = 50
) -> None
```

Upload, select, and configure an arbitrary waveform in one call.

| Parameter | Type | Description |
|-----------|------|-------------|
| `waveform_data` | np.ndarray | Waveform data (0-2047 range, uint16) |
| `name` | str | Waveform name (stored in non-volatile memory) |
| `frequency` | float | Output frequency in Hz (default: 5000) |
| `voltage` | float | Peak-to-peak voltage in volts (default: 0.5) |
| `load` | int | Load impedance in ohms (default: 50) |

**Waveform requirements:**
- Values: 0-2047 (12-bit DAC, mid-scale ~1024)
- Length: 8-16000 points
- Type: `numpy.uint16` (will be converted if needed)

---

## Waveform Upload

### upload_waveform

```python
awg.upload_waveform(waveform_data, name: str = "PULSE") -> None
```

Upload waveform to volatile memory and copy to named storage.

| Parameter | Type | Description |
|-----------|------|-------------|
| `waveform_data` | np.ndarray | Waveform data (0-2047, uint16) |
| `name` | str | Storage name for the waveform |

The waveform is first uploaded to volatile memory, then copied to the named location for persistent storage.

---

### select_waveform

```python
awg.select_waveform(name: str = "PULSE") -> None
```

Select a previously uploaded waveform from memory.

| Parameter | Type | Description |
|-----------|------|-------------|
| `name` | str | Name of stored waveform |

---

### set_function_shape_user

```python
awg.set_function_shape_user() -> None
```

Set function shape to USER (arbitrary waveform mode). Call this after selecting a waveform to activate it.

---

## Output Configuration

### configure_output

```python
awg.configure_output(frequency: float = 5000, voltage: float = 0.5, load: int = 50) -> None
```

Configure output frequency, voltage (Vpp), and load impedance.

| Parameter | Type | Description |
|-----------|------|-------------|
| `frequency` | float | Output frequency in Hz |
| `voltage` | float | Peak-to-peak voltage in volts |
| `load` | int | Load impedance in ohms |

---

## Utility Methods

### reset

```python
awg.reset() -> None
```

Reset AWG to default settings.

---

### check_errors

```python
awg.check_errors() -> str
```

Query AWG for errors.

**Returns:** Error string ("+0,No error" if none)

---

## Complete Example

```python
import numpy as np
from gtape_prologix_drivers import PrologixAdapter, HP33120A

adapter = PrologixAdapter(port="COM4", gpib_address=10)
awg = HP33120A(adapter)

# Create a custom waveform (sine with harmonics)
t = np.linspace(0, 2*np.pi, 1000)
wave = np.sin(t) + 0.3*np.sin(3*t) + 0.1*np.sin(5*t)

# Normalize to -1..+1, then scale to 0-2047 range
wave_normalized = wave / np.max(np.abs(wave))
wave_scaled = ((wave_normalized + 1) / 2 * 2047).astype(np.uint16)

# Upload and configure in one call
awg.setup_arbitrary_waveform(
    waveform_data=wave_scaled,
    name="HARMONIC",
    frequency=1000,    # 1 kHz
    voltage=2.0,       # 2 Vpp
    load=50            # 50Î© load
)

# Or do it step by step:
# awg.upload_waveform(wave_scaled, name="HARMONIC")
# awg.select_waveform("HARMONIC")
# awg.set_function_shape_user()
# awg.configure_output(frequency=1000, voltage=2.0, load=50)

adapter.close()
```

## Waveform Tips

1. **Mid-scale (~1024)** = zero voltage when centered
2. **0** = negative peak, **2047** = positive peak
3. Use **numpy** for efficient waveform generation
4. Longer waveforms = better resolution but slower update rate
5. Waveforms are stored persistently after upload (survives power cycle)
